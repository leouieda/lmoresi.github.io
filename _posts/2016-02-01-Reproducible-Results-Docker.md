---
layout: post
title: 'Reproducible, Reviewable Scientific Code with Docker'
date: 2016-02-01 # YYYY-MM-DD hh:mm
published: true # Won't build unless true
comments: true
categories: ['draft','none']
#image: # default is used if blank. Otherwise use images stored in the _images/posts folder
#  feature: "posts/2015-05-03 10.01.27 HDR.png"
#  credit: Louis Moresi
---

We recently decided to focus on distributing [Docker images with Underworld2](http://www.underworldcode.org/posts/Underworld-and-Dockers2/) pre-installed. This was primarily to make our lives easier in deploying our software on multiple platforms.

Docker does this by bundling all the dependencies from the operating system upwards into a single image which can be run consistently independent of the underlying hardware. Thus, the original motivation of portability also ensures _reproducibility_ of results generated by the code.

I have mixed feelings about the need for perfect reproducibility and I was arguing against the idea when we held the ["Data Explosion"](http://rses.anu.edu.au/cadi/Whiteconference/) meeting in 2006. The idea that perfect reproducibility is the only way to validate a scientific result actually struck me as a dangerous one. Surely no physical phenomenon can be dependent on whether you compiled your code on this or that variant of Unix or which compiler flags were set ? So I thought that recording such things was a waste of effort that could be going into better algorithms and so on.

But, with Docker, the effort argument does not apply and instead we might ask whether it is useful to be able to rerun a computation in a forensic, or perhaps, diagnostic fashion.

In order to do this it is not just a question of being able to re-run a calculation but to re-explore the context of the calculation: to examine the sensitivity to the original assumptions and verify the interpretation of the results in developing the conclusions. In other words, it is possible to critically review a piece of work at any time, and build upon / extend that work.

This is, of course, what science is all about and is also the philosophy of the open-source movement.

Exactly as we do with open-source code, this idea also requires that we make docker images which are transparent in explaining what the binary layers contain, document the installation, are clear about the versions of software which are baked in, document the code itself, provide the source, and provide the relevant input files.

Docker really does allow us to bundle up the whole machine, but fully reproducible results / reviewable scientific software demands that we provide not just a working binary but also transparency with source code for every step along the path to final results.  

This is a venerable idea (see Schwab et al, 2000). The guarantee that Docker provides in terms of the run-time environment removes many of the constraints that they faced in developing a general procedure for long-lived reproducibility but still requires a commitment from the researcher to their audience.

To start the ball rolling, I started building a module which makes it easy to bundle up web pages  / files / jupyter notebooks and make a front end to a Docker image. The module contains the jekyll engine to turn markdown files into web pages, example pages / instructions and scripts to set up the jupyter engine to serve the web site and live content correctly.

<figure >
	<a href="/images/posts/KitematicWebEngine/SafariWebInterface.png"><img src="/images/posts/KitematicWebEngine/SafariWebInterface.png"></a>
	<figcaption> Static landing page to guide you to live notebooks / terminals where you can run wild with a live code installation
    </figcaption>
</figure>

The idea is to make a simple / familiar landing page for any docker container that provides a stable, immutable return point when exploring the live content.


## References

Schwab, M., N. Karrenbach, and J. Claerbout (2000), Making scientific computations reproducible, Computing In Science and Engineering, 2(6), 61â€“67, doi:10.1109/5992.881708.





References:
